# Gobang Pygame

## 待办任务

- [x] 找到合适的UI原壳：https://download.csdn.net/download/qq_36408085/10694129
- [x] 开始菜单
- [x] win函数更改为（i，j）附近判断
- [x] 增加防误触（棋盘外无法落子）
- [x] 三层游戏树，用alphabeta树实现getscore，并用actions(position)函数缩小搜索空间
- [x] 悔棋repent
- [x] 增加用键盘控制播放棋谱
- [x] 最小幅度修改chesslist,chessindex, lst, index, 以节省运算时间并适配alphabeta树算法。（或者也可以每次都deepcopy）
- [x] 预剪枝
- [x] 棋谱加入试下
- [x] 模式切换/托管
- [x] 编写readme文档
- [ ] 如果可能，增加强化学习算法。（**很蓝的啦**~）

 ## AI核心算法

- [x] 启发式评估

- [x] Alpha-beta剪枝

  辅助视频：

  https://youtu.be/l-hh51ncgDI

  https://mathspp.com/blog/minimax-algorithm-and-alpha-beta-pruning#the-minimax-algorithm
  
  https://www.youtube.com/watch?v=xBXHtz4Gbdo
  
  初始-**Minimax算法**
  
  ```python
  # 定义正负无穷
  pinf = float('inf')
  ninf = float('-inf')
  
  def minimax(board, depth, player):
      if player: #如果为玩家1
          return max_value(board, depth)
      else: #如果为玩家0
          return min_value(board, depth)
  def max_value(board, depth):
      if terminal(board): # 如果游戏结束，或叶节点（终态）
          return get_score(board) # 返回当前的价值(由get_score(chesslist, i, j, score)函数计算)
      v = ninf
      for action in actions(board): # 对于每一个可能的动作
          v = max(v, min_value(result(board, action), depth+1)) # 对于每一个动作，选取落子并经过对方最小化后的最大值
      return v
  def min_value(board, depth):
      if terminal(board):
          return get_score(board)
      v = pinf
      for action in actions(board):
          v = min(v, max_value(get_score(board, action), depth+1))
      return v
  ```

增加剪枝：

```python
# implement alpha-beta pruning

# 顺序：分成子树，先从下到上，再从左到右（因此次序对于剪纸很重要）

# Alpha=最大化程序在根路径上已探索过的最大选择
# Beta=最小化程序在根路径上已探索过的最小选择

def alphabeta(position,depth,alpha,beta,player):
    if depth == 0:
        return get_score(position)
    if player:
        maxEval=ninf
        for action in actions(position):
            evaluate = alphabeta(action,depth-1,alpha,beta,False) # 将position的child赋给eval。传参时，处理的子树会获知[已处理子树的根节点的取值信息]。
            maxEval = max(evaluate,maxEval) 
            alpha = max(alpha,evaluate) # 一棵子树清理完毕，就更新一次alpha。
            if beta <= alpha: # 如果在某个节点处，对方的最小值小于我方最大，那么对面肯定不会选这一支（因为传的minimax值>=alpha）,剪掉这一action.
                break
        return maxEval
    else:
        minEval=pinf
        for action in actions(position):
            evaluate = alphabeta(action,depth-1,alpha,beta,True)
            minEval = min(evaluate,minEval)
            beta = min(beta,evaluate)
            if beta <= alpha:
                break
        return minEval
```



## UI界面

Pygame模块学习: 

《用Python和Pygame写游戏-从入门到精通》 

https://eyehere.net/2011/python-pygame-novice-professional-index/ （或许有些过时）

Cheatsheet: http://inventwithpython.com/pygamecheatsheet.png

https://www.geeksforgeeks.org/pygame-tutorial/

https://developpaper.com/implementation-of-gobang-game-in-python-pygame-version/

https://github.com/suragnair/alpha-zero-general



## 遇到的重要问题

白棋活三，黑棋堵，白棋冲四，黑棋堵之后没有奖励，分数仍然为0，因此黑棋不会选择堵。

但若奖励白棋死四，白棋不会选择冲四，分数仍为0.

解决方式：

白棋死四罚项。此举看似很反常识，或许亦是minimax的本质吧。
